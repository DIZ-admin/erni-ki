---
language: ru
translation_status: complete
doc_version: '2025.11'
last_updated: '2025-12-01'
---

# Стандарты качества кода

Единый набор правил для внутренних скриптов, сервисов и инфраструктурных
артефактов. Соблюдение стандарта является обязательной входной точкой для code
review и CI.

## 1. Цели и область применения

- Обеспечить стабильность платформы ERNI-KI и воспроизводимость сборок.
- Снизить риски за счёт единообразных правил по безопасности, тестам и стилю.
- Ускорить онбординг: все проекты (Go, Python, JS/TS, Bash, Infra-as-Code)
  следуют одному чек-листу.
- Обеспечить прослеживаемость: любые исключения документируются, согласуются и
  имеют срок действия.
- Поддерживать качество документации на уровне ≥ 95/100 по внутренней шкале
  зрелости (полнота, актуальность, пригодность к действию).

### Роли и ответственность

- **Автор** — обеспечивает наличие тестов, документации и актуальных чек-листов
  для своего изменения.
- **Ревьюер** — проверяет выполнение стандартов, валидирует риски и чётко
  фиксирует замечания.
- **Владелец продукта/компонента** — утверждает исключения из правил и сроки их
  закрытия.

### Уровни строгости и исключения

- Блокирующие: безопасность, утечки секретов, отсутствие тестов для публичного
  API, падение линтеров — нельзя мёрджить без фикса.
- Предупреждения: косметические несоответствия стиля при явном согласовании с
  ревьюером, если не нарушают читаемость и не несут риск.
- Исключения оформляются через комментарий в PR с обоснованием, сроком и
  ответственным; фиксируются в CHANGELOG или документации.
- Каждое исключение сопровождается планом устранения и меткой даты просрочки;
  ревьюеры отслеживают их закрытие в следующих релизах.

### Управление документацией

- Владелец компонента назначает **куратора документации**, который отвечает за
  свежесть инструкций и контроль качества текста.
- Перед релизом обязательно провести мини-аудит: обновить примеры запуска,
  команды CI, переменные окружения и ссылки на ADR.
- Для пользовательских изменений публикуйте краткое резюме (tl;dr), список
  влияний на пользователей и проверенные сценарии (smoke-check).

## 2. Обязательные принципы (для всех языков)

- **Стиль и форматирование:** запускайте форматтеры перед коммитом (`gofmt`,
  `ruff format`, `eslint --fix`, `shfmt`). Не отключайте правила lint без
  причины и без комментария.
- **Типизация и контракты:** включайте строгие режимы (`pyproject.toml` с
  `mypy`/`ruff`, `tsconfig.json` с `strict: true`, `go vet`).
- **Тестируемость:** каждый новый модуль сопровождайте unit-тестами; без тестов
  изменения не принимаются. Минимум — happy path + негативные кейсы.
- **Ошибки и логирование:** используйте структурированные логи, возвращайте
  информативные ошибки с контекстом; не глушите исключения/ошибки.
- **Зависимости:** фиксируйте версии (`go.mod`, `requirements*.txt`,
  `package-lock.json`), избегайте прямых `latest`. Удаляйте невостребованные
  пакеты.
- **Безопасность:** запрещены секреты в коде/логах. Включайте линтеры
  безопасности (Trivy, `npm audit`, `pip-audit`, `gosec`) и устраняйте
  блокирующие находки.
- **Документация:** публичные функции/скрипты сопровождайте docstring/`//`
  комментариями. Обновляйте README/mkdocs при изменении поведения.
- **Прослеживаемость:** связывайте изменения с задачами/тикетами, указывайте
  ссылки в описании PR. В CHANGELOG отражайте значимые пользовательские
  изменения и миграции.

## 3. Языковые профили

### Go

- Форматирование: `gofmt` + `goimports` обязательны.
- Проверки: `go vet`, `staticcheck` (если доступен в проекте),
  `go test ./... -race` для сервисов, использующих конкурентность.
- Ошибки: заворачивайте ошибки через `fmt.Errorf("context: %w", err)`; не
  теряйте оригинальный `err`.
- Конфигурация: храните в `.env`/`config` с валидацией; не используйте
  глобальные переменные для состояния.
- Тесты: покрывайте конкурентные участки `-race` и таблицами тестов; избегайте
  глобального состояния между кейсами.

### Python

- Линтеры: `ruff check` + `ruff format`, опционально `mypy` для критичных путей.
- Импорты: сортировка `ruff --select I`; не используйте `from module import *`.
- Исключения: ловите только ожидаемые типы, не скрывайте стеки; логируйте через
  структурированные логгеры.
- Пакеты: объявляйте версии в `requirements*.txt`; для CLI-утилит используйте
  `argparse/typer` с подробным `--help`.
- Тесты: используйте `pytest` с `pytest-cov`, фикстуры для подготовки окружения,
  маркируйте интеграционные тесты и отделяйте их в CI.

### JavaScript/TypeScript

- Типобезопасность: `strict` режим в `tsconfig.json`; избегайте `any` и `!` без
  пояснения.
- Линтеры/форматтеры: `eslint`, `prettier` (если подключён), `npm run lint` в
  CI.
- Тесты: `vitest`/`jest` минимум для публичных функций и UI-компонентов;
  снапшоты храните под контролем версий.
- UI: не смешивайте логику и представление; отделяйте хуки/сервисы от
  компонентов.
- Доступность (a11y): проверяйте контраст, фокусируемость, ARIA-атрибуты для
  интерактивных элементов; добавляйте истории в Storybook при наличии.

### Bash и CLI-скрипты

- Шебанг `#!/usr/bin/env bash` и `set -euo pipefail` обязательны.
- Проверяйте входные параметры, выводите понятные сообщения об ошибках.
- Не используйте `sudo` внутри скриптов; требуйте права заранее.
- Совместимость: пишите POSIX-совместимые конструкции, если не требуется
  специфичный Bash 5.x.

## 4. Git и pull requests

- Коммиты атомарные, с описательными сообщениями в повелительном наклонении.
- Перед PR обязательно: `npm run lint`, `npm run test`, `go test ./...` (для
  Go), `ruff check`, `pre-commit run --all-files` — согласно стеку изменения.
- Запрещено форс-пушить в `main`/`develop`. Все изменения проходят через PR и
  review.
- Изменения конфигурации/секретов сопровождайте миграционными инструкциями в
  `docs/` или в описании PR.
- Требование минимальных воспроизводимых окружений: для CLI/скриптов добавляйте
  пример запуска с набором переменных и зависимостей; для сервисов — команду для
  локального старта.
- Документация по изменениям — часть определения готовности (Definition of
  Done): без обновления Usage/ADR/README изменение не принимается.

## 5. Документация и комментирование

- Каждый публичный API/CLI имеет раздел "Usage" и примеры. Изменения интерфейсов
  отражайте в `docs/api/` или `docs/reference/`.
- Внутренние функции документируйте кратко: цель, входы/выходы, ключевые
  побочные эффекты.
- Не дублируйте знания: источник правды выбирается один (код или документ с
  автогенерацией). Обновляйте статусы и версии вместе с релизами.
- Для архитектурных решений фиксируйте ADR с контекстом, альтернативами и
  критериями выбора. Обновляйте диаграммы при изменении потоков данных.
- Поддерживайте единый стиль написания документации: актуальная дата, версионный
  тег, короткое резюме изменений и ссылки на связанные задачи.
- Готовность документации измеряйте по шкале 0–100: полнота (40%), актуальность
  (35%), применимость/пошаговость (25%). Минимум для мёрджа — 95.
- Для CLI и API добавляйте блоки: входные параметры, коды ответов/ошибок,
  примеры вызова, ограничения и частые ловушки (gotchas).
- Для инфраструктуры и CI/CD фиксируйте источники секретов, схемы хранения
  артефактов и политику ротации ключей.

## 6. Контроль качества и CI/CD

- В CI запрещено игнорировать падение линтеров/тестов; `allow_failures` только
  для экспериментальных матриц с явной пометкой.
- Покрытие: для новых модулей не ниже 80%; снижение покрытие допустимо только с
  оформленным исключением и планом на рост.
- Подписи контейнеров/артефактов: включайте SBOM и результаты сканирования на
  уязвимости; не публикуйте артефакты с критичными находками.
- Каталоги артефактов сборки должны быть исключены из коммитов, если не являются
  частью релиза.
- Включайте шаг проверки документации в CI: сборка mkdocs, линт ссылок, проверку
  примеров команд (doctest/`make docs-verify`) и наличие обновлённых версий/дат.
- После релиза фиксируйте итоговую оценку качества документации и ключевые риски
  в `DOCUMENTATION_AUDIT_REPORT.md` или сопутствующем ADR.

## 7. Самооценка и контроль списка

- Раз в квартал проводите самоаудит по чек-листу: синхронизация версий, актуалы
  переменных окружения, наличие сценариев восстановления и проверенных примером
  команд запуска.
- Храните результаты аудита в репозитории (reports/ или docs/quality) с датой и
  ответственным.
- Для статей/гайдов используйте шаблон: цель → контекст → требования к среде →
  пошаговая инструкция → валидация результата → ошибки/траблшутинг → ссылки.
- Любой найденный долг фиксируется тикетом с датой закрытия и попадает в
  ближайший релизный план.

## 8. Чек-лист code review

- [ ] Линтеры/форматтеры пройдены, нет отключённых правил без обоснования.
- [ ] Покрытие тестами достаточное; негативные сценарии учтены.
- [ ] Ошибки и логи содержат контекст, нет глушения исключений.
- [ ] Зависимости и версии актуализированы; нет секретов в коде/конфигурации.
- [ ] Документация и миграционные заметки обновлены; примеры запуска проверены.
- [ ] Наличие ADR/диаграмм при значимых архитектурных изменениях.
- [ ] Обоснованы все исключения и зафиксированы сроки их закрытия.

Соблюдение этих стандартов обеспечивает предсказуемое качество, ускоряет ревью и
снижает эксплуатационные риски.
