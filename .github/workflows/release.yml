# Release Pipeline for erni-ki project
# Automated releases with semantic versioning

name: ðŸš€ Release

on:
  push:
    branches: [main]
    paths-ignore:
      - "docs/**"
      - "*.md"
      - ".github/workflows/ci.yml"
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major

# Permissions for creating releases
permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Determine release version
  version:
    name: ðŸ“‹ Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸŸ£ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: "1.3.3"

      - name: ðŸ“¦ Install semantic-release
        run: |
          bun install --global semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github

      - name: ðŸ·ï¸ Generate version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual release
            CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            CURRENT_VERSION=${CURRENT_VERSION#v}

            case "${{ github.event.inputs.release_type }}" in
              "major")
                NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print ($1+1)".0.0"}')
                ;;
              "minor")
                NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."($2+1)".0"}')
                ;;
              "patch")
                NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."($3+1)}')
                ;;
            esac

            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "changelog=Manual release: ${{ github.event.inputs.release_type }} version bump" >> $GITHUB_OUTPUT
          else
            # Automated release via semantic-release
            bunx semantic-release --dry-run --no-ci > release-output.txt 2>&1 || true

            if grep -q "The next release version is" release-output.txt; then
              VERSION=$(grep "The next release version is" release-output.txt | sed 's/.*The next release version is //')
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "tag=v$VERSION" >> $GITHUB_OUTPUT
              echo "changelog=Automated release based on conventional commits" >> $GITHUB_OUTPUT
            else
              echo "version=" >> $GITHUB_OUTPUT
              echo "tag=" >> $GITHUB_OUTPUT
              echo "changelog=" >> $GITHUB_OUTPUT
            fi
          fi

  # Build and test before release
  pre-release:
    name: ðŸ§ª Pre-release Tests
    runs-on: ubuntu-latest
    needs: [version]
    if: needs.version.outputs.version != ''

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: ðŸ¹ Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: auth/go.mod
          cache-dependency-path: auth/go.sum

      - name: ðŸ§ª Run comprehensive tests
        working-directory: ./auth
        run: |
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out

      - name: ðŸ”’ Security scan (pinned toolchain)
        env:
          GOTOOLCHAIN: go1.24.10
          GOSEC_VERSION: v2.15.0
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@${GOSEC_VERSION}
          gosec ./auth/... || echo "gosec exited non-zero (known upstream SSA panic); continuing"
        continue-on-error: true

  # Create release
  release:
    name: ðŸš€ Create Release
    runs-on: ubuntu-latest
    needs: [version, pre-release]
    if: needs.version.outputs.version != ''

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ”¡ Normalize repository to lowercase
        id: repo-lc
        run: |
          repo_lc=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo_lc=${repo_lc}" >> "$GITHUB_OUTPUT"

      - name: âœ… Validate Docker tags are lowercase
        run: |
          {
            echo "${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:${{ needs.version.outputs.version }}"
            echo "${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:latest"
          } | bash scripts/utilities/check-docker-tags.sh

      # Build and push Docker images with release tags
      - name: ðŸ—ï¸ Build and push release images
        uses: docker/build-push-action@v5
        with:
          context: ./auth
          file: ./auth/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:${{ needs.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:latest
          labels: |
            org.opencontainers.image.title=erni-ki-auth
            org.opencontainers.image.description=JWT Authentication service for erni-ki
            org.opencontainers.image.version=${{ needs.version.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Create GitHub release
      - name: ðŸ“‹ Generate changelog
        id: changelog
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "changelog=${{ needs.version.outputs.changelog }}" >> $GITHUB_OUTPUT
          else
            # Generate changelog based on commits
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
            if [ -n "$PREVIOUS_TAG" ]; then
              CHANGELOG=$(git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
            fi

            # Escape for GitHub Actions
            CHANGELOG="${CHANGELOG//'%'/'%25'}"
            CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
            CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"

            echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ·ï¸ Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a ${{ needs.version.outputs.tag }} -m "Release ${{ needs.version.outputs.version }}"
          git push origin ${{ needs.version.outputs.tag }}

      - name: ðŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: Release ${{ needs.version.outputs.version }}
          body: |
            ## ðŸš€ Release ${{ needs.version.outputs.version }}

            ### ðŸ“‹ Changes
            ${{ steps.changelog.outputs.changelog }}

            ### ðŸ³ Docker Images
            - `${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:${{ needs.version.outputs.version }}`
            - `${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:latest`

            ### ðŸ“Š Metrics
            - Build time: ${{ github.run_number }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}

            ### ðŸ”— Links
            - [Docker Image](${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth)
            - [Commit](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          draft: false
          prerelease: false

  # Release notifications
  notify:
    name: ðŸ“¢ Notify Release
    runs-on: ubuntu-latest
    needs: [version, release]
    if: always() && needs.version.outputs.version != ''

    steps:
      - name: ðŸ”¡ Normalize repository to lowercase
        id: repo-lc
        run: |
          repo_lc=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo_lc=${repo_lc}" >> "$GITHUB_OUTPUT"

      - name: ðŸ“Š Create release summary
        run: |
          echo "## ðŸš€ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.release.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Image**: \`${{ env.REGISTRY }}/${{ steps.repo-lc.outputs.repo_lc }}/auth:${{ needs.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
