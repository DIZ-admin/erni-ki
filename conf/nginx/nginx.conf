user nginx;
worker_processes auto;
worker_rlimit_nofile 262144; # Increased for high load

# Critical service logs at INFO for web server diagnostics
error_log /var/log/nginx/error.log info;
pid /var/run/nginx.pid;

events {
  worker_connections 16384; # Increased from 8192 for higher throughput
  use epoll; # Best choice for Linux
  multi_accept on; # Accept multiple connections at once
}

http {
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  # ============================================================================
  # GZIP COMPRESSION CONFIGURATION - performance optimized
  # ============================================================================

  # Gzip compression to reduce traffic
  gzip on;
  gzip_vary on;
  gzip_min_length 1024;
  gzip_proxied any;
  gzip_comp_level 6;
  gzip_types
  text/plain
  text/css
  text/xml
  text/javascript
  application/json
  application/javascript
  application/xml+rss
  application/atom+xml
  image/svg+xml;

  # ============================================================================
  # CORRELATION ID CONFIGURATION - logging optimization
  # ============================================================================

  # Generate unique Request ID for tracing
  map $request_id $correlation_id {
    default $request_id;
  }

  # Reuse client-provided X-Request-ID when present
  map $http_x_request_id $final_request_id {
    default $correlation_id;
    ~.+ $http_x_request_id;
  }

  log_format compression '$remote_addr - $remote_user [$time_local] '
  '"$request" $status $body_bytes_sent '
  '"$http_referer" "$http_user_agent" "$gzip_ratio" '
  'request_id="$final_request_id"';

  # Log format for rate limiting with correlation ID
  log_format rate_limit_json escape=json '{'
  '"timestamp":"$time_iso8601",'
  '"remote_addr":"$remote_addr",'
  '"request":"$request",'
  '"status":$status,'
  '"request_time":$request_time,'
  '"upstream_response_time":"$upstream_response_time",'
  '"user_agent":"$http_user_agent",'
  '"referer":"$http_referer",'
  '"host":"$host",'
  '"request_id":"$final_request_id",'
  '"service":"nginx",'
  '"level":"warn"'
  '}';

  # Flag for rate limiting log
  map $status $rate_limit_log {
    429 1;
    default 0;
  }

  # Default access log
  access_log /var/log/nginx/access.log combined;

  # Access log for rate limit events
  access_log /var/log/nginx/rate_limit.log rate_limit_json if=$rate_limit_log;

  # Return Request-ID in each response
  add_header X-Request-ID $final_request_id always;

  # Upstream error log with correlation ID
  log_format upstream_errors '$time_iso8601 [$status] $request_method $scheme://$host$request_uri '
  'upstream: $upstream_addr response_time: $upstream_response_time '
  'client: $remote_addr user_agent: "$http_user_agent" '
  'request_id: "$final_request_id"';

  # Detailed SearXNG log with correlation ID
  log_format searxng_detailed '$time_iso8601 [$status] $request_method $request_uri '
  'response_time: $request_time upstream_time: $upstream_response_time '
  'client: $remote_addr query: "$args" user_agent: "$http_user_agent" '
  'request_id: "$final_request_id"';

  # Flag for upstream error logging
  map $status $log_upstream_errors {
    ~^5 1; # 5xx errors
    default 0;
  }

  # Flag for SearXNG issues (errors + slow queries)
  map $status $log_searxng_issues {
    ~^[45] 1; # 4xx and 5xx errors
    default 0;
  }

  # Flag for slow requests (>2s)
  map $request_time $log_slow_requests {
    ~^[2-9] 1; # 2+ seconds
    ~^[0-9][0-9] 1; # 10+ seconds
    default 0;
  }

  access_log /var/log/nginx/upstream_errors.log upstream_errors if=$log_upstream_errors;

  sendfile on;
  keepalive_timeout 65;

  # DNS resolver for Docker with short TTL
  resolver 127.0.0.11 valid=10s ipv6=off;
  resolver_timeout 5s;

  # WebSocket upgrade mapping (safe defaults)
  map $http_upgrade $connection_upgrade {
    default close;
    "websocket" upgrade;
  }

  # Real IP configuration (Cloudflare + Docker bridge)
  include /etc/nginx/includes/cloudflare-ips.conf; # Generated from https://www.cloudflare.com/ips/
  set_real_ip_from 172.16.0.0/12; # Docker internal networks
  real_ip_header CF-Connecting-IP;
  real_ip_recursive on;

  # Rate limiting tuned for ERNI network
  # Detect trusted IPs (internal ERNI ranges)
  geo $is_trusted_ip {
    default 0;
    127.0.0.1/32 1;
    10.0.0.0/8 1;
    172.16.0.0/12 1;
    192.168.0.0/16 1;
    # Add ERNI-specific ranges if needed
  }

  # Rate limiting zones (explicit keys)
  # Trust handled via ACL in locations, not empty keys
  map $is_trusted_ip $rate_is_trusted {
    1 1; 0 0;
  }

  # CORS origin reflect with explicit allowlist
  map $http_origin $cors_ok {
    default 0;
    "~^https?://(ki\.erni-gruppe\.ch|diz\.zone|localhost(:\d+)?|127\.0\.0\.1(:\d+)?)$" 1;
  }

  # Detect requests coming via Cloudflare tunnel (port-based)
  map $server_port $is_cloudflare_tunnel {
    default 0;
    8080 1;
  }

  # Conditional X-Request-ID header for Cloudflare tunnel
  map $is_cloudflare_tunnel $request_id_header {
    default "";
    1 $final_request_id;
  }

  # Universal Request-ID variable for includes
  map $is_cloudflare_tunnel $universal_request_id {
    default $final_request_id;
    1 $final_request_id;
  }

  limit_req_zone $binary_remote_addr zone=general:20m rate=50r/s;
  limit_req_zone $binary_remote_addr zone=api:20m rate=30r/s;
  limit_req_zone $binary_remote_addr zone=static:20m rate=100r/s;
  limit_req_zone $binary_remote_addr zone=auth:10m rate=5r/s;
  limit_req_zone $binary_remote_addr zone=searxng_api:10m rate=60r/s;
  limit_req_zone $binary_remote_addr zone=searxng_web:10m rate=40r/s;
  limit_req_zone $binary_remote_addr zone=docling_api:10m rate=5r/s;
  limit_req_zone $binary_remote_addr zone=litellm_api:10m rate=10r/s;
  limit_req_zone $binary_remote_addr zone=ollama_api:10m rate=5r/s;

  # Connection limiting
  limit_conn_zone $binary_remote_addr zone=perip:10m;
  limit_conn_zone $server_name zone=perserver:10m;

  # Cache for static assets (persistent path)
  proxy_cache_path /var/cache/nginx/static levels=1:2 keys_zone=static_cache:100m
  max_size=1g inactive=60m use_temp_path=off;

  # Cache for SearXNG search responses (persistent path)
  proxy_cache_path /var/cache/nginx/searxng levels=1:2 keys_zone=searxng_cache:256m
  max_size=2g inactive=30m use_temp_path=off;

  # Upstreams are defined in conf.d/default.conf
  include /etc/nginx/conf.d/*.conf;
}
