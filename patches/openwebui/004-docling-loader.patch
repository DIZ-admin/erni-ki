--- a/open_webui/retrieval/loaders/main.py
+++ b/open_webui/retrieval/loaders/main.py
@@ -3,6 +3,7 @@
 import ftfy
 import sys
 import json
+import time
 
 from azure.identity import DefaultAzureCredential
 from langchain_community.document_loaders import (
@@ -132,12 +133,35 @@
 
 
 class DoclingLoader:
-    def __init__(self, url, file_path=None, mime_type=None, params=None):
+    def __init__(
+        self,
+        url,
+        file_path=None,
+        mime_type=None,
+        params=None,
+        async_mode=False,
+        poll_interval=3,
+        max_poll_attempts=600,
+    ):
         self.url = url.rstrip("/")
         self.file_path = file_path
         self.mime_type = mime_type
 
         self.params = params or {}
+        self.async_mode = async_mode
+        self.poll_interval = poll_interval or 3
+        self.max_poll_attempts = max_poll_attempts or 600
+
+    def _raise_docling_error(self, response, prefix="Error calling Docling API"):
+        error_msg = f"{prefix}: {response.reason}"
+        if response.text:
+            try:
+                error_data = response.json()
+                if "detail" in error_data:
+                    error_msg += f" - {error_data['detail']}"
+            except Exception:
+                error_msg += f" - {response.text}"
+        raise Exception(f"Error calling Docling: {error_msg}")
 
     def load(self) -> list[Document]:
         with open(self.file_path, "rb") as f:
@@ -201,28 +225,54 @@
                     params["pipeline"] = self.params.get("pipeline")
 
             endpoint = f"{self.url}/v1/convert/file"
-            r = requests.post(endpoint, files=files, data=params)
-
-        if r.ok:
-            result = r.json()
-            document_data = result.get("document", {})
-            text = document_data.get("md_content", "<No text content found>")
-
-            metadata = {"Content-Type": self.mime_type} if self.mime_type else {}
-
-            log.debug("Docling extracted text: %s", text)
-
-            return [Document(page_content=text, metadata=metadata)]
-        else:
-            error_msg = f"Error calling Docling API: {r.reason}"
-            if r.text:
-                try:
-                    error_data = r.json()
-                    if "detail" in error_data:
-                        error_msg += f" - {error_data['detail']}"
-                except Exception:
-                    error_msg += f" - {r.text}"
-            raise Exception(f"Error calling Docling: {error_msg}")
+            if self.async_mode:
+                submit_resp = requests.post(f"{endpoint}/async", files=files, data=params)
+                if not submit_resp.ok:
+                    self._raise_docling_error(submit_resp)
+
+                task = submit_resp.json()
+                task_id = task.get("task_id")
+                if not task_id:
+                    raise Exception("Docling async response missing task_id")
+
+                status = task.get("task_status")
+                attempts = 0
+                while status not in ("success", "failure"):
+                    if attempts >= self.max_poll_attempts:
+                        raise Exception(
+                            f"Docling async polling timed out after {attempts} attempts"
+                        )
+                    time.sleep(self.poll_interval)
+                    poll_resp = requests.get(f"{self.url}/v1/status/poll/{task_id}")
+                    if not poll_resp.ok:
+                        self._raise_docling_error(poll_resp, "Error polling Docling status")
+                    task = poll_resp.json()
+                    status = task.get("task_status")
+                    attempts += 1
+
+                if status != "success":
+                    raise Exception(
+                        f"Docling async task failed with status '{status}': {task}"
+                    )
+
+                result_resp = requests.get(f"{self.url}/v1/result/{task_id}")
+                if not result_resp.ok:
+                    self._raise_docling_error(result_resp, "Error fetching Docling result")
+                result = result_resp.json()
+            else:
+                r = requests.post(endpoint, files=files, data=params)
+                if not r.ok:
+                    self._raise_docling_error(r)
+                result = r.json()
+
+        document_data = result.get("document", {})
+        text = document_data.get("md_content", "<No text content found>")
+
+        metadata = {"Content-Type": self.mime_type} if self.mime_type else {}
+
+        log.debug("Docling extracted text: %s", text)
+
+        return [Document(page_content=text, metadata=metadata)]
 
 
 class Loader:
@@ -343,6 +393,9 @@
                     file_path=file_path,
                     mime_type=file_content_type,
                     params=params,
+                    async_mode=self.kwargs.get("DOCLING_USE_ASYNC", False),
+                    poll_interval=self.kwargs.get("DOCLING_POLL_INTERVAL", 3),
+                    max_poll_attempts=self.kwargs.get("DOCLING_MAX_POLL_ATTEMPTS", 600),
                 )
         elif (
             self.engine == "document_intelligence"
